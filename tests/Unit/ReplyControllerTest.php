<?php

namespace Tests\Unit;


use App\Http\Controllers\ReplyController;
use App\Http\Wrapper\FakeBroadcastWrapper;
use App\Model\Category;
use App\Model\Like;
use App\Model\Question;
use App\Model\Reply;
use App\UseCase\Question\FindQuestionUseCase;
use App\UseCase\Reply\CreateReplyUseCase;
use App\UseCase\Reply\TestPushReplyNotificationUseCase;
use App\User;
use Illuminate\Foundation\Testing\WithFaker;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Mockery;
use Mockery\Mock;
use Tests\TestCase;


class ReplyControllerTest extends TestCase
{
    use RefreshDatabase;

    private $question;

    public function setUp(): void
    {
        parent::setUp(); // TODO: Change the autogenerated stub

        factory(User::class, 10)->create();
        factory(Category::class, 5)->create();
        factory(Question::class, 50)->create();
        factory(Reply::class, 50)->create()->each(function ($reply) {
            return $reply->like()->save(factory(Like::class)->make());
        });

        $this->question = factory(Question::class, 1)->create([
            "title" => "testQuestion"
        ])->first();
        factory(Reply::class, 3)->create([
            "question_id" => $this->question->id
        ])
            ->each(function ($reply) {
                return $reply->like()->save(factory(Like::class)->make());
            });
    }

    /** @test */
    public function it_can_store()
    {

        $this->withoutExceptionHandling();
        $fakeBroadcastWrapper = new FakeBroadcastWrapper();

        $fakeMock = Mockery::mock(ReplyController::class,
            [
                $this->app->make(FindQuestionUseCase::class),
                $this->app->make(CreateReplyUseCase::class),
                $this->app->make(TestPushReplyNotificationUseCase::class),
                false
            ])
            ->makePartial();

        $fakeMock->shouldReceive("broadcast")
            ->withAnyArgs($fakeBroadcastWrapper)
            ->andReturn("");


        $this->app->bind(ReplyController::class, function () use ($fakeMock) {
            return $fakeMock;
        });

        $user = $this->signIn();

        $data = [
            "body" => "dummyBody",
            "user_id" => $user->id
        ];
        $ret = json_decode($this->post("/api/question/" . $this->question->id . "/reply", $data)->content(), true);

        self::assertEquals("dummyBody", $ret["reply"]["reply"]);
        self::assertEquals($this->question->id, $ret["reply"]["question_id"]);
        self::assertEquals($user->id, $ret["reply"]["user_id"]);

    }

    /** @test */
    public function it_can_not_notify_if_question_user_id_equals_reply_user_id()
    {

        $fakeBroadcastWrapper = new FakeBroadcastWrapper();

        $fakeMock = Mockery::mock(ReplyController::class,
            [
                $this->app->make(FindQuestionUseCase::class),
                $this->app->make(CreateReplyUseCase::class),
                $this->app->make(TestPushReplyNotificationUseCase::class),
                false
            ])
            ->makePartial();

        $fakeMock->shouldReceive("broadcast")
            ->withAnyArgs($fakeBroadcastWrapper)
            ->andReturn("");


        $this->app->bind(ReplyController::class, function () use ($fakeMock) {
            return $fakeMock;
        });

        $user = $this->signIn();

        $question = factory(Question::class, 1)->create([
            "title" => "testQuestion",
            "user_id" => $user->id
        ])->first();

        $data = [
            "body" => "dummyBody",
            "user_id" => $user->id
        ];

        //reply_userId = question_user_id,自分で作った質問に返答してもnotifyしない
        $ret = json_decode($this->post("/api/question/" . $question->id . "/reply", $data)->content(), true);

        self::assertNotTrue(TestPushReplyNotificationUseCase::$isNotify);
    }

    /** @test */
    public function it_can_notify_if_question_user_id_not_equals_reply_user_id()
    {

        $fakeBroadcastWrapper = new FakeBroadcastWrapper();

        $fakeMock = Mockery::mock(ReplyController::class,
            [
                $this->app->make(FindQuestionUseCase::class),
                $this->app->make(CreateReplyUseCase::class),
                $this->app->make(TestPushReplyNotificationUseCase::class),
                false
            ])
            ->makePartial();

        $fakeMock->shouldReceive("broadcast")
            ->withAnyArgs($fakeBroadcastWrapper)
            ->andReturn("");


        $this->app->bind(ReplyController::class, function () use ($fakeMock) {
            return $fakeMock;
        });

        $user = $this->signIn();



        $data = [
            "body" => "dummyBody",
            "user_id" => $user->id
        ];

        //reply_userId = question_user_id,自分で作った質問に返答してもnotifyしない
        $ret = json_decode($this->post("/api/question/" . $this->question->id . "/reply", $data)->content(), true);

        self::assertTrue(TestPushReplyNotificationUseCase::$isNotify);
    }

    protected function tearDown()
    {
        parent::tearDown(); // TODO: Change the autogenerated stub
        TestPushReplyNotificationUseCase::teardown();
    }
}
